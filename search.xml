<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java-GC]]></title>
      <url>%2F2017%2F01%2F25%2FJava-GC%2F</url>
      <content type="text"><![CDATA[对于Java的垃圾回收，主要体现在三个问题上：When，What，How。GC是在什么时候，对什么东西，做了什么事情。 对于Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化）因此在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存的分配和回收都是动态的，GC所关注的是这部分内存。 When大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 PS: Minor GC和Full GC的区别 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对），Major GC的速度一般会比Minor GC慢10倍以上。 长期存活的对象将进入老年代，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1，对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会晋升到老年代中。 对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。 动态对象年龄判断：为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 空间分配担保，在发生Minor GC之前，虚拟机将会先检查老年代中最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机则会查看HandlepromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时要改为进行一次Full GC。 “冒险”：如果Minor GC时出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 如果允许担保失败，但某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败，如果担保失败，那就只好在失败后重新发起一次Full GC。 大部分情况下还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。（JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC） What从GC Roots搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 方法区（Hotspot虚拟机中的永久代）Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规引用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容： 废弃常量：假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 无用的类：同时满足下面3个条件才能算是“无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 ps：虚拟机可以对满足上述3个条件的无用类进行回收，仅仅是“可以”，并不是和对象一样，不使用了就必然会回收。在大量使用反射、动态代理。CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 Java堆Java堆一般分为新生代和老年代不同区域的对象，大多数情况下，对象在新生代Eden区中分配。大对象直接进入老年代，或者Eden区进行Minor GC时Survivor区的空间不足时某些对象将直接进入老年代，或者对象达到老年代的年龄阈值时将进入老年代。 How （判断哪些对象需要回收）引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。主流的Java虚拟机没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 其中可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性所引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 两次标记过程即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，将会被第一次标记并进行一次筛选，判断此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（任何一个对象的finalize()对象都只会被系统自动调用一次），虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它，这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。 这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象这时候还没有逃脱，那基本上就真的被回收了。 PS: finalize()方法不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或者其他方式都可以做的更好、更及时，所以完全可以忘掉Java中有这个方法的存在。 How （垃圾收集算法）标记-清除算法首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记过程即上面所说的两次标记过程。不足：一个是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。 复制算法解决上面的效率问题：将内存分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后将已使用过的内存空间一次清理掉，不用考虑内存碎片问题。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保，这些在Survivor中没有空间存放的存活对象将直接通过分配担保机制进入老年代。 标记-整理算法对于老年代中的对象存活率较高，所以一般不能直接选用复制收集算法。于是有人提出了“标记-整理算法”，标记过程仍然和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”算法，一般是把Java堆分为新生代和老年代，在新生代中，每次GC都有大批对象死去，只有少量存活，所以选用复制算法；而老年代中因为对象存活率高、没有额外空间进行分配担保，就必须使用“标记-清除”或“标记-整理”算法来进行回收。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP拥塞控制]]></title>
      <url>%2F2016%2F09%2F27%2FTCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[当路由器上的队列增长到很大时，网络层检测到拥塞，并试图通过丢弃数据包来管理拥塞。传输层接收到从网络层反馈过来的拥塞信息，并减慢它发送到网络的流量速率。 拥塞窗口TCP维持一个拥塞窗口，通过使用基于AIMD（加法递增乘法递减）控制法来相应从网络传来的二进制拥塞信号（把丢包当成这个二进制信号）。窗口大小是任何时候发送端可以往网络发送的字节数，相应的速率大小是窗口大小除以连接的往返时间。 除了维护一个拥塞窗口外，还有一个在TCPvsUDP中提到过的通告窗口也就是流量控制窗口，该窗口指出了接收端可以缓冲的字节数。要并发跟踪这两个窗口，能发送的字节数是两个窗口中较小的那个。因此有效窗口是发送端认为的应该大小和接收端认为的应该大小的较小者。 如果拥塞窗口或流量控制窗口暂时已满，则TCP将停止发送数据。 如果接收端说“发送64KB数据”，但发送端知道超过32KB的突发将阻塞网络，它就只发送32KB；另一方面，如果接收端说“发送64KB数据”，发送端知道高达128KB的突发通过网络都毫不费力，它会发送要求的全部64KB。 拥塞控制的算法拥塞控制算法的思想是避免拥塞，而不是控制拥塞。 慢速启动当建立连接时，发送端用一个很小的值初始化拥塞窗口，最多不超过4个段，然后发送端发送该初始窗口大小的数据。数据包必须经过一个往返时间才被确认。对于每个重传计时器超时前得到承认的段，发送端的拥塞窗口增加一个段的字节量。此外，随着该段获得确认，现在网络中又少了一段。结果是每个被确认的段允许发送两个段，每经过一个往返时间拥塞窗口增加一倍。见下图：(cwnd线性增长) 由于慢速启动导致拥塞窗口按指数增长，最终（很快而不是很晚）它将太多的数据包以太快的速度发到网络，当发生这种情况时，网络中将很快建立起队列。当队列满时，一个或多个包会被丢弃。为了保持对慢速启动的控制，发送端为每个连接维持一个 慢启动阈值（slow start threshold） 。每当检测到丢包，比如超时了，慢启动阈值就被设置为当前拥塞窗口的一般，整个过程再重新启动。基本思想是当前窗口太大，因为它在过去造成了拥塞，所以现在才检测到超时。 一旦慢速启动超过了阈值，TCP就从慢速启动切换到线性增加（加法递增）。在这种模式下，每个往返时间拥塞窗口只增加一段。 快速重传发送端有一个快速方法来识别它的包已经被丢失。当丢失数据包的后续数据包到达接收端时，它们触发给发送端返回确认。这些确认段携带着相同的确认号，称为重复确认。TCP假设三个重复确认意味着已经丢失一个包。丢失包的序号可以从确认号推断出来，它是整个数据序列中紧接着的下一个数据包。因此，这个包可以被立即重传，在其计时器超时前就重新发送出去。见下图：（快速重传） 重传后，慢启动阈值被设置为当前拥塞窗口的一半，就像发生了超时一样。如果在一个往返时间内确认了该重传的数据包以及丢包之前已发出的所有数据，则重新开始慢启动过程，在到达阈值之前窗口大小指数增长，到达阈值时开始线性增长。见下图：(TCP Tahoe的慢速启动后面接着线性递增) 快速恢复快速恢复算法是在快速重传算法后添加的，当收到3个重复确认时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速恢复的思想是“数据包守恒”原则，即同一时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开网络后，才能向网络中发送一个“新”的数据包。如果发送方收到一个重复确认，就表明有一个数据包离开了网络，于是cwnd加1。 具体来说快速恢复的主要步骤是： 当收到3个重复确认时，把ssthreshold设置为cwnd的一半，把cwnd设置为ssthreshold的值加3，然后重传丢失的报文段。（加3是因为收到三个重复确认，表明有个3个“老”的数据包离开了网络）。 再收到重复确认时，cwnd加1。（此时还没收到丢包的那个确认，所以收到后面的包都会发送重复确认） 快速重传之后的一个往返时间后，丢失的包将被确认。在这个时间点，重复确认将停止，快速恢复模式就此退出。拥塞窗口将被设置到新的慢启动阈值，并开始按线性增长。 TCP Reno的快速恢复模式和锯齿模式： New RenoTCP的许多复杂性来自于从一个重复确认流中推断出已经到达和已经丢失的数据包，累计确认号无法提供这种确切的信息。一个简单的解决方法是使用选择确认（SACK，Selective ACKnowledgement），该确认列出了3个已接收的字节范围。有了这个信息，发送端在实现拥塞窗口时可以直接确定哪些数据包需要重传，并跟踪那些还在途中的数据包。 SACK是严格意义上的咨询信息，实际上使用重复确认来检查丢包和调整拥塞窗口还是像以前一样。然而，有了SACK，TCP可以更加容易地从同时丢失多个包的情况下恢复过来，因为TCP发送端知道哪些数据包尚未收到。 补充除了用丢包作为拥塞信号外，显式拥塞通知（ECN，Explicit Congestion Notification）也用来作拥塞信号使用。ECN是IP层的机制，主要用来通知主机发生了拥塞。 当发送端和接收端在建立连接过程中设置了ECE和CWR标志位，双方均表示他们能够使用这些标志位后，该TCP连接就可以启用ECN信号。支持ECN的路由器在接近拥塞时就会在携带ECN标志的数据包上设置拥塞信号，而不是在拥塞发生后丢弃这些数据包。 如果到达的任何数据包携带了ECN拥塞信号，则会告知TCP接收端。然后接收端使用ECE标志位给TCP发送端发送通知，告知它的数据包经历了拥塞。发送端通过拥塞窗口减少（CWR）标志位告诉接收端它已经收到拥塞信号了。 TCP发送端收到这些拥塞通知消息的反应和它根据重复确认检测到丢包的处理方式完全相同。严格来说这种情况更好，拥塞已经被检测出来了，而且没有包收到任何方式的损害。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM Memory]]></title>
      <url>%2F2016%2F09%2F23%2FJavaMemory%2F</url>
      <content type="text"><![CDATA[Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 —-摘自《深入理解Java虚拟机》 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。Java虚拟机所管理的内存将会包括以下几个运行时数据区域：方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中方法区和堆是由所有线程共享的数据区，后三个是线程隔离的数据区。 程序计数器程序计数器是一块较小的内存空间，他可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令，因此每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined） Java虚拟机栈Java虚拟机栈也是线程私有的，它的生命周期和线程相同。主要用来存放基本类型变量，局部变量以及对象的引用（所以将一个对象作为方法的参数时，在方法中改变对象的值，也会影响到原来的对象的值）。每个方法在执行的同时都会创建一个栈帧用于 存储局部变量表、操作数栈、动态链接、方法出口 等信息。每个方法从调用之至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址） 其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的只占用1个。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别在于虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 有的虚拟机（如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。 本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常 Java堆Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。（随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换技术将会导致所有的对象都在堆上变得不是那么“绝对了”） Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。 方法区方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾收集。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。(String类的intern()方法，intern()方法设计的初衷，就是重用String对象，以节省内存消耗。) 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 在JDK1.4中新加入了 NIO（New I/O）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 本机总内存受到Java堆以及直接内存的限制，因此在配置虚拟机参数时，只根据实际内存设置-Xmx等参数信息，但如果忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。 注：文中图片来自Google图片]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCPvsUDP]]></title>
      <url>%2F2016%2F09%2F22%2FTCPvsUDP%2F</url>
      <content type="text"><![CDATA[UDP是一个简单的、不可靠的数据报协议，而TCP是一个复杂的、可靠的字节流协议。 用户数据报协议 UDPUDP是一个简单的传输层协议，应用进程往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。 缺乏可靠性：如果一个数据报到达了其最终目的地，但是校验和检测发现有错误，或者该数据报在网络传输途中被丢弃了，它就无法被投递给UDP套接字，也不会被源端自动重传。（如果想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆的特性：来自对端的确认、本端的超时与重传等。） 每个UDP数据报都有一个长度，如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一起传递给接收端应用进程。（TCP是一个字节流协议，没有任何记录边界，这一点不同于UDP） UDP提供无连接的服务，因为UDP客户与服务器之间不必存在任何长期的关系。 传输控制协议 TCPTCP提供客户与服务器之间的连接，TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。 可靠性当TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃，如此在尝试发送数据上所花的总时间一般为4~10分钟（依赖于具体实现）。 note: TCP并不保证数据一定会被对方端点接收，因为这是不可能做到的。如果有可能，TCP就把数据递送给对方端点，否则就（通过放弃重传并中断连接这一手段）通知用户。所以说，TCP也不能被描述成是100%可靠的协议，它提供的是数据的可靠递送或故障的可靠通知。 动态估算RTTTCP含有动态估算客户和服务器之间的往返时间（round-trip time, RTT）的算法，以便知道等待一个确认需要多少时间。 RTT在一个局域网上大约是几毫秒，跨越一个广域网则可能是数秒钟。另外RTT受网络流通各种变化因素影响，TCP还持续估算一个给定连接的RTT 序列号TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序。分节是TCP传递给IP的数据单元，比如说一个应用写2048个字节到一个TCP套接字，导致TCP发送两个分节：第一个的序列号为1~1024，第二个的序列号为1025~2048。如果这些分节非顺序到达，接收端TCP将先根据他们的序列号重新排序，再把结果传递给接收应用。 如果接收端TCP接收到来自对端的重复数据（比如说对端认为一个分节已丢失并因此重传，而这个分节并没有真正丢失，只是网络通信过于拥挤），它可以根据序列号判定数据是重复的，从而丢弃重复数据。 流量控制TCP提供流量控制（flow control）。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为通告窗口（advertised window）。在任何时刻，该窗口指出接收缓冲区当前可用的空间量，从而确保发送端发送的数据不会使接收端缓冲区溢出。 该窗口时刻动态变化：当接收来自发送端的数据时，窗口大小就减小，但是当接收端应用从缓冲区中读取数据时，窗口大小就增大。 通告窗口大小减小到0是有可能的：当TCP对某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据时，方能从对端再接收数据。 UDP不提供流量控制，让较快的UDP发送端以一个UDP接收端难以跟上的速率发送数据报是非常容易的。 全双工TCP连接是全双工的（full-duplex）。意味着在一个给定的连接上应用可以在任何时刻在进出两个方向上既发送数据又接收数据。因此，TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。 建立一个全双工连接后，需要的话可以转换成一个单工连接。 UDP可以是全双工的。 总结UDP本身不提供确认、序列号、RTT估算、超时和重传等机制。这些都是由UDP应用来处理这些情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TipsOfJava]]></title>
      <url>%2F2016%2F03%2F24%2FTipsOfJava%2F</url>
      <content type="text"><![CDATA[收集了一些有关java的知识点，并持续更新相关的知识点。 面向对象编程的三大特性是什么？请简要阐述1）继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继 承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增 加新的方法使之更适合特殊的需要。 2）封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 3）多态：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 ArrayList,Vector,LinkedList的存储性能和特性ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized思路方法(线程安全) ，通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项前后项即可，所以插入速度较快。 Collection 和 Collections的区别Collection是集合类的上级接口，继承于他的接口主要有Set和List. Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 String 和 StringBuffer的区别JAVA平台提供了两个类:String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据这个String类提供了数值不可改变字符串，而这个StringBuffer类提供的字符串进行修改当你知道字符数据要改变的时候你就可以使用StringBuffer，可以使用StringBuffers来动态构造字符数据。 HashMap 和 Hashtable的区别HashMap是Hashtable的轻量级实现(非线程安全的实现)，他们都完成了Map接口，主要区别在于HashMap允许空(null)键值(key),由于非线程安全，效率上可能高于Hashtable，HashMap允许将Null作为一个entryde key 或者value,而Hashtable不允许 HashMap把Hashtable的contains思路方法去掉了，改成containsvalue和containsKey因为contains思路方法容易让人引起误解Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的区别是，Hashtable的思路方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的思路方法实现同步，而HashMap 就必须为它的思路方法提供外同步。 Hshtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 （有时间会总结一下java中不同的Map的区别） final, finally, finalize的区别1）final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 2）finally是异常处理语句结构的一部分，表示总是执行。 3）finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 Overload 和 Override的区别。Overloaded的方法是否可以改变返回值的类型?为什么Java可以运行在不同的平台上？Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言编译程序只需生成在Java虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 为了跨平台特性，字节码是不能直接在机器上运行的，需要有一个虚拟机（JVM）来解释执行。而不同平台底层肯定不一样，所以不同平台上的JVM是不一样的。JVM就负责把通用的字节码解释成对应平台的底层代码去执行。(JVM是通过C++实现的） Java中非静态方法能不能调用静态成员？不能，因为静态的方法可以在没有创建实例时使用，而申明为非静态的成员变量是一个对象属性，它只有在对象存在是引用，因此如果在对象为创建实例时我们在静态方法中调用了非静态成员自然是非法的，所以编译器会在这个时候报错。 123456789import java.util.*;class Test&#123; int i = 0; public static int main(String[] args)&#123; System.out.println(i); &#125;&#125; 上面的例子编译的时候编译器会出现下面的错误12Test.java:7: 错误: 无法从静态上下文中引用非静态 变量 i System.out.println(i);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet/Filter/Listener/Interceptor]]></title>
      <url>%2F2016%2F03%2F17%2FServlet-Filter-Listener-Interceptor%2F</url>
      <content type="text"><![CDATA[Servlet/Filter/Listener/Interceptor的区别和联系 ServletServlet是一种运行服务器端的Java应用程序，具有独立于平台和协议的特性，并且可以动态的生成Web页面，他工作在客户端请求与服务器响应的中间层。Servlet的主要功能在于交互式地浏览和修改数据，生成动态Web内容： 客户端发送请求至服务器端 服务器将请求信息发送至Servlet Servlet生成响应内容并将其传给服务器，响应内容动态生成，通常取决于客户端的请求 服务器将响应返回给客户端 在Web应用程序中，一个Servlet在一个时刻可能被多个用户同时访问，此时Web服务器将为每个用户创建一个线程来执行Servlet。如果Servlet不涉及共享资源的问题，不必关心多线程问题，但如果Servlet需要共享资源，需要保证Servlet是线程安全的。 Servlet的生命周期： 装入：启动服务器时装入Servlet的实例 初始化：在Web服务器第一次接收到请求时（除非特殊指定：load-on-start Servlet，否则在容器启动时，Servlet是不会被加载和实例化得）初始化由init()方法执行完成 调用：从第一次到以后的多次访问，都只调用doGet()和doPost()方法 销毁：停止服务器时调用destroy()方法，销毁实例 使用@WebServlet注解来开发Servlet，如果你不喜欢使用xml配置而喜欢注解的话，Servlets API同样提供了一些注解接口给你。你可以像下面的例子一样使用 @WebServlet 注解并且不需要在web.xml里为Servlet注册任何信息。容器会自动注册你的Servlet到运行环境，并且像往常一样处理它。1234567891011121314151617181920212223import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;MyFirstServlet&quot;, urlPatterns = &#123;&quot;/MyFirstServlet&quot;&#125;)public class MyFirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some work &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some other work &#125;&#125; FilterFilter过滤器，主要用于对用户请求Request进行预处理，也可以对Response进行后处理，是个典型的处理链。使用Filter的完整流程： Filter对用户请求进行预处理 将用户请求HttpServletRequest交给Servlet进行处理并生成相应 Filter再对生成的服务器响应HttpServletResponse进行后处理 Filter的生命周期： 启动服务器时加载过滤器的实例，并调用init()方法来初始化实例 每次请求时都只调用方法doFilter()进行处理 停止服务器时调用destroy()方法，销毁实例 Filter的种类： 用户授权的Filter：Filter负责检查用户请求，过滤用户非法请求 日志Filter：详细记录某些特殊的用户请求 负责解码的Filter：包括对非标准编码的请求解码 能改变XML内容的XSLT Filter等 Filter可负责拦截多个请求或响应，一个请求或响应也可被多个请求拦截 Filter既可以在web.xml中配置，也可以通过@WebFilter注解来配置相应的Filter。 其实Struts2本身就是一个总的过滤器12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;多个匹配的Filter，是按照其在web.xml中配置的顺序来执行的，所以这也就是把自己的Filter或者其他的Filter（比如UrlRewrite的Filter）放在Struts的DispatcherFilter的前面的原因。因为它们需要在请求被Struts2框架处理之前，做一些前置的工作。当Filter被调用，并且进入了Struts2的DispatcherFilter中后，Struts2会按照在Action中配置的Interceptor Stack中的Interceptor的顺序，来调用Interceptor。 Listener监听器，通过Listener可以监听web服务器中某一个执行动作，并根据其要求做出相应的响应通俗来说就是在application，session，request三个对象创建消亡或者往其中添加删除属性时自动执行代码的功能组件。比如Spring的总监听器会在服务器启动的时候实例化我们配置的bean对象，Hibernate的session监听器会监听session的活动和生命周期，负责创建关闭session等活动。Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 常用的Listener： 与servletContext有关的listner接口。包括：ServletContextListener、ServletContextAttributeListener 与HttpSession有关的Listner接口。包括：HttpSessionListner、HttpSessionAttributeListener、HttpSessionBindingListener、 HttpSessionActivationListener； 与ServletRequest有关的Listener接口，包括：ServletRequestListner、ServletRequestAttributeListener Interceptor在面向切面编程（AOP)时，在service或者一个方法的前面或者方法后面调用一个方法，是基于Java的反射机制，比如动态代理就是拦截器的简单实现。 Interceptor的生命周期： void init(): 在该拦截器被初始化之后，被执行拦截之前，系统会调用该方法，对每个拦截器而言，此方法只执行一次 String intercept(ActionInvocation) throws Exception: 该方法是用户需要实现的拦截动作，该方法会返回一个字符串 void destroy: 该方法跟init()方法对应，在拦截器实例被销毁之前，系统会调用该方法 区别Servlet流程是短的，url传来之后，就对其进行处理，之后返回或转到某一指定的页面。 Filter流程是线性的，url传来之后，通过检查之后，可保持原来的流程继续向下执行，被下一个Filter或Servlet接收等，而Servlet处理之后，不会继续向下传递。Filter可用来进行字符编码的过滤，检测用户是否登录，禁止页面缓存等。 Listener是针对对象的操作，而Servlet和Filter都是针对url之类的，Listener可用来进行：Spring整合Struts，为Struts的action注入属性，web应用定时任务的实现，在线人数的统计等。 Interceptor拦截器类似于Filter，不过不是在web.xml中配置，而是在struts.xml中配置，并且不是针对url的，而是针对action，当页面提交action时进行过滤操作，可由action自己指定用哪个Interceptor来在接收之前做响应的拦截操作。 Struts2中的过滤器与拦截器的区别与联系： 拦截器是基于Java反射机制的，而过滤器是基于函数回调的 过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器 拦截器只能对action请求起作用，而过滤器则可以对几乎所有请求起作用 在action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello MyBlog]]></title>
      <url>%2F2015%2F09%2F23%2FMyBlog%2F</url>
      <content type="text"><![CDATA[My blog –”Just for Fun” is online, I will write something about my route of learning coding. It will be a amazing procsess.]]></content>
    </entry>

    
  
  
</search>
